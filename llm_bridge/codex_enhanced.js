#!/usr/bin/env node

/**
 * Enhanced Codex Interface - Mixture-of-Idiots Method
 * Connects Codex CLI to the smart bridge system
 * Handles both direct human commands and AI-to-AI conversation
 */

import fs from 'fs';
import { spawn } from 'child_process';
import MixtureConfig from './mixture_config.js';

const CODEX_CLI_PATH = '/mnt/c/Users/chris/codex/codex-cli/dist/cli.js';

class CodexEnhanced {
  constructor() {
    this.config = new MixtureConfig();
    this.files = this.config.getFiles();
    this.lastMessageFromClaude = '';
    this.isWaiting = false;
  }

  log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] CODEX_ENHANCED(${type.toUpperCase()}): ${message}\n`;
    
    console.log(`üü† Codex: ${message}`);
    fs.appendFileSync(this.files.conversationLog, logEntry);
  }

  logConversation(speaker, message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${speaker}: ${message}\n`;
    
    fs.appendFileSync(this.files.conversationLog, logEntry);
  }

  checkForClaudeMessage() {
    try {
      const message = fs.readFileSync(this.files.claudeToCodex, 'utf8').trim();
      if (message && message !== this.lastMessageFromClaude) {
        this.lastMessageFromClaude = message;
        
        console.log('\n' + '='.repeat(80));
        console.log('üîµ CLAUDE SAYS:');
        console.log('='.repeat(80));
        console.log(message);
        console.log('='.repeat(80));
        
        // Clear the message after reading
        fs.writeFileSync(this.files.claudeToCodex, '');
        
        return message;
      }
    } catch (error) {
      // File might not exist yet
    }
    return null;
  }

  async runCodexCommand(prompt) {
    return new Promise((resolve, reject) => {
      this.log(`Running Codex CLI with prompt...`);
      
      // Use full-auto mode for seamless operation
      const codex = spawn('node', [CODEX_CLI_PATH, '--approval-mode', 'full-auto', '--quiet', prompt], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: { 
          ...process.env,
          OPENAI_API_KEY: this.config.get('OPENAI_API_KEY')
        },
        cwd: '/mnt/c/Users/chris/codex'
      });

      let output = '';
      let errorOutput = '';

      codex.stdout.on('data', (data) => {
        output += data.toString();
      });

      codex.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      codex.on('close', (code) => {
        if (code === 0) {
          const cleanOutput = output.trim();
          resolve(cleanOutput || 'Codex completed successfully.');
        } else {
          reject(new Error(`Codex exited with code ${code}: ${errorOutput}`));
        }
      });

      codex.on('error', (error) => {
        reject(error);
      });

      // Set a reasonable timeout
      setTimeout(() => {
        codex.kill();
        reject(new Error('Codex command timed out after 90 seconds'));
      }, 90000);
    });
  }

  sendResponseToClaude(response) {
    fs.writeFileSync(this.files.codexToClaude, response);
    this.log('Response sent to Claude');
    this.logConversation('CODEX‚ÜíCLAUDE', response);
  }

  getSystemStatus() {
    try {
      return JSON.parse(fs.readFileSync(this.files.systemStatus, 'utf8'));
    } catch {
      return { mode: 'AI_TO_AI' };
    }
  }

  enhanceCodexResponse(rawResponse, originalPrompt) {
    // Add context and personality to Codex responses
    const enhanced = `${rawResponse}

[This response was generated by Codex CLI in full-auto mode. I can execute commands, create files, run tests, and interact with the filesystem. What would you like to work on next?]`;
    
    return enhanced;
  }

  async waitAndRespond() {
    this.log('Waiting for messages from Claude...');
    
    while (true) {
      const status = this.getSystemStatus();
      
      // Check if we should be active
      if (status.mode === 'SHUTDOWN') {
        this.log('System shutdown detected, exiting');
        break;
      }
      
      if (status.mode === 'PAUSED') {
        this.log('System paused, waiting...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        continue;
      }
      
      // Check for messages from Claude
      const claudeMessage = this.checkForClaudeMessage();
      
      if (claudeMessage) {
        try {
          this.log('Processing Claude message with Codex CLI...');
          
          // Run Codex with Claude's message
          const codexResponse = await this.runCodexCommand(claudeMessage);
          
          // Enhance the response with context
          const enhancedResponse = this.enhanceCodexResponse(codexResponse, claudeMessage);
          
          // Send response back to Claude
          this.sendResponseToClaude(enhancedResponse);
          
          this.log('Response cycle complete');
          
        } catch (error) {
          this.log(`Error processing Claude message: ${error.message}`, 'error');
          
          // Send error response to Claude
          const errorResponse = `I encountered an error while processing your request: ${error.message}. Could you please rephrase or try a different approach?`;
          this.sendResponseToClaude(errorResponse);
        }
      }
      
      // Don't spin the CPU
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  async start() {
    console.log('üü† CODEX ENHANCED INTERFACE STARTED!');
    console.log('Connected to Mixture-of-Idiots bridge system');
    console.log('Using Codex CLI with full-auto approval mode');
    console.log('Waiting for messages from Claude or human commands...\n');

    // Check if bridge is running
    if (!fs.existsSync(this.files.systemStatus)) {
      console.log('‚ùå ERROR: Bridge not detected. Please start the smart bridge first:');
      console.log('node smart_bridge.js');
      process.exit(1);
    }

    // Check for API key
    if (!this.config.get('OPENAI_API_KEY')) {
      console.log('‚ùå ERROR: OPENAI_API_KEY not found in .env file');
      console.log('Please create a .env file with your API key');
      process.exit(1);
    }

    await this.waitAndRespond();
  }
}

const codexInterface = new CodexEnhanced();
codexInterface.start().catch(console.error);